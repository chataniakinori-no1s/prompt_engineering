# ワーク3: 信頼性の向上（自己検証）- AIに提案書をレビューさせる

## サンプル課題
システムエンジニアの高橋さん。ワーク2でAIとの対話を通じて、パフォーマンス改善のための複数の技術的アプローチ（Eager Loading, キャッシュ戦略など）のメリット・デメリットを深く理解しました。

> **高橋さんの思考:**
> 「AIとの議論のおかげで、まずは短期的な改善策として『Eager Loading』を実装し、中長期的には『キャッシュ戦略』の導入を検討するという、バランスの取れた方針が見えてきた。これをチームに提案するための、簡単な技術ドキュメントをAIに作ってもらったけど、本当にこれで完璧だろうか…？」

> **田中さんからのアドバイス:**
> 「高橋さん、そのドキュメント、すごく分かりやすいよ。ただ、僕のような非エンジニアから見ると、まだ少し専門用語が多いかもしれない。それに、他のエンジニアから『なぜその方法なの？』という鋭いツッコミが来た時に、しっかり答えられる準備も必要じゃないかな。」

AIが生成したアウトプットの信頼性を、AI自身に検証させる「自己検証」。この最終関門を突破し、誰が見ても納得できる鉄壁の技術ドキュメントを完成させましょう。

## 解説

### AIに「自らの回答」の穴を塞がせる自己検証プロンプト

**自己検証**は、メタ認知をさらに一歩進め、AIが生成したアウトプットの**論理的な一貫性、正当性、説得力**を、AI自身に厳しくチェックさせるプロンプト技術です。これは、特に報告書や提案書、技術ドキュメントなど、第三者の合意形成が必要な文書を作成する際の、最終品質チェックとして絶大な効果を発揮します。

- **論理の飛躍や矛盾を発見**: 「この主張の根拠はどこにありますか？」「AとBの結論は、本当に関連性がありますか？」といった問いかけで、論理的な弱点をあぶり出します。
- **想定される反論への対策**: 「もしあなたがこの提案に反対の立場なら、どのような反論をしますか？」と尋ねることで、事前に弱点を補強し、質疑応答に備えることができます。
- **信頼性の向上**: AIによるセルフチェックのプロセスを経ることで、生成された文章の客観性と信頼性が大幅に向上します。

成功の鍵は、AIの回答を肯定的に受け入れるだけでなく、**あえて批判的な視点（クリティカルシンキング）**をAIに与え、自らの生成物に対する「あら探し」をさせることです。

### サンプル課題解答

**【シチュエーション】**
高橋さんは、チームに提案するため、「N+1クエリ問題の短期的な改善策として、Eager Loadingを実装する」という方針をまとめた技術説明ドキュメントの下書きをAIに作成させました。

**▼ プロンプト例（ステップ1: 技術説明ドキュメントの下書き作成）**
```
あなたは、チーム向けの技術ドキュメントを作成するのが得意なソフトウェアエンジニアです。
APIのパフォーマンスを低下させている「N+1クエリ」問題の短期的な改善策として、「Eager Loading」を実装する方針です。

この方針について、開発チーム内で合意形成するための、簡潔な技術説明ドキュメントを作成してください。
```

**▼ AIによる出力例（ドキュメントの下書き）**
```
### N+1クエリ問題の改善提案：Eager Loadingの導入

**1. 問題の概要**
現在、`/api/v1/translate`エンドポイントにおいて、ループ処理内で都度DBクエリが発行されるN+1クエリ問題が発生しており、これがパフォーマンス劣化の主原因となっています。

**2. 解決策**
短期的な改善策として、ORMフレームワークのEager Loading機能（例: `JOIN FETCH`）を導入します。これにより、ループ前に必要な関連データを一括で取得し、発行されるクエリ数を1回に最適化します。

**3. 期待される効果**
本対応により、DBへのクエリ発行回数が劇的に減少し、APIのレスポンスタイムが大幅に改善されることが期待されます。
```
---
**【シチュエーション（続き）】**
この下書きを見た高橋さんは、田中さんのアドバイスを思い出し、このドキュメントが本当に分かりやすく、説得力があるか不安になりました。そこで彼は、AIに自己検証をさせ、ドキュメントの品質をチェックすることにしました。

**▼ プロンプト例（ステップ2: 自己検証による信頼性向上）**
```
素晴らしい下書きをありがとうございます。最終化する前に、内容をレビューしてください。

あなたは、このプロジェクトの技術的背景に詳しくないプロダクトマネージャーの田中さんです。
今あなたが作成したこの技術説明ドキュメントを読んで、率直に「分かりにくい」と感じる点や、「なぜ？」と疑問に思う点を挙げてください。
その上で、あなたが完全に納得できるように、ドキュメントを修正してください。
```

**▼ AIによる出力例（自己検証と改善案）**
```
承知いたしました。プロダクトマネージャーの田中として、このドキュメントをレビューします。

### PM 田中としてのレビュー

- **分かりにくい点1**: 「N+1クエリ」という言葉が、そもそも何が問題なのか直感的に分かりません。
- **分かりにくい点2**: 「Eager Loading」や「JOIN FETCH」が、なぜ解決策になるのか、その仕組みがイメージできません。
- **疑問点**: なぜこれが「短期的」な改善策なのですか？長期的な策は他にあるのでしょうか？

### ドキュメントの改善案

上記のレビューに基づき、以下のようにドキュメントを修正します。

---
### **【改善案】APIパフォーマンス改善のご提案：まずは「まとめ買い」でムダをなくしましょう！**

**1. 今、何が起きているか？（問題の概要）**
現在、翻訳APIは、データベースへのお願い（クエリ）を非常に非効率な方法で行っています。
ワーク1のたとえ話で言うと、**10個の商品を買うために、11回もスーパーへの出入りを繰り返している**状態です。これが、APIが遅い根本原因（N+1クエリ問題）です。

**2. どうやって解決するか？（解決策）**
まずは、この無駄な出入りをなくすため、**「Eager Loading（事前一括読み込み）」**という方法で、**最初に買うものリストを渡し、一度の入店で全ての商品をまとめてカートに入れる**ように修正します。これにより、データベースへのお願いは、たった1回で済むようになります。

**3. なぜ、これが「今」ベストな方法なのか？**
この方法は、既存の仕組み（ORMフレームワーク）の機能を活用するため、**比較的少ないコード修正で、迅速かつ確実に効果を出せる**という大きなメリットがあります。
もちろん、将来的には専用の高速な倉庫（キャッシュ）を用意するような、より大掛かりな改善も考えられますが、まずはこの「まとめ買い」作戦で、お客様が感じているストレスを最速で解消することが、最も賢明な判断だと考えています。
---
```
---
### 練習問題1

**【シチュエーション】**
非エンジニアにも分かりやすい説明になり、高橋さんは満足しました。しかし、今度はチームのシニアエンジニアからの、より技術的な視点でのツッコミが気になり始めました。「Eager Loadingは便利だけど、使い方を間違えると逆にパフォーマンスが悪化することもある。そのリスクは考慮しているのか？」といった指摘が来るかもしれません。

さあ、実際にChatGPTやGeminiなどの対話AIを使い、この**技術的なリスクに対する懸念を、AI自身に検証させる**自己検証プロンプトを作成してみましょう。

### Hint
ここでも、批判的なペルソナを与えることが有効です。今回は**「コードの品質と長期的な保守性に非常に厳しい、ベテランのテックリード」**という役割を与えてみましょう。このペルソナは、提案された解決策の「良い面」だけでなく、「潜在的な副作用」や「将来の負債になる可能性」に目を光らせるはずです。「このEager Loadingという解決策を導入する際に、技術的に注意すべき潜在的な落とし穴を3つ挙げ、それぞれに対する予防策を追記するように」と指示することで、よりリスクを考慮した、信頼性の高い提案に進化させることができます。

**▼ プロンプト例**
```
ありがとうございます。非常に分かりやすくなりました。
最後に、技術的な観点からのレビューをお願いします。

あなたは、コードの品質と長期的な保守性に非常に厳しい、ベテランのテックリードです。
先ほどあなたが修正した提案書を読み、「Eager Loading」という解決策を導入する際に、技術的に注意すべき「潜在的な落とし穴」を3つ指摘してください。
そして、その落とし穴を避けるための具体的な対策を、提案書に追記する形で示してください。
```

**▼ AIによる出力例**
```
承知いたしました。テックリードとして、Eager Loading導入の潜在的な落とし穴と、その対策を指摘します。提案書に以下のセクションを追記することを推奨します。

---
### **4. 導入時に考慮すべき技術的リスクと対策**

Eager Loadingは強力な解決策ですが、導入には以下の点に注意が必要です。

**リスク1: 過剰なデータ取得（オーバーフェッチ）**
- **落とし穴**: 必要以上の関連データまで一括で取得してしまい、メモリ使用量が増大し、かえってパフォーマンスが悪化する可能性があります。
- **対策**: 取得する関連データを必要最小限に絞り込みます。また、コードレビュー時には、取得対象のデータ範囲が適切か、必ず確認するプロセスを設けます。

**リスク2: 複雑なクエリの生成**
- **落とし穴**: 複数の深い階層の関連を一度に取得しようとすると、ORMが非常に複雑で非効率なSQLクエリを生成してしまうことがあります。
- **対策**: Eager Loadingを適用するのは、原則として1階層から2階層までの関連に限定します。それ以上に複雑な場合は、クエリを分割するか、別の最適化手法を検討します。

**リスク3: 仕様変更への追従漏れ**
- **落とし穴**: 将来的に関連データの持ち方が変更された際に、Eager Loading部分の修正を忘れ、意図せずN+1クエリが再発する可能性があります。
- **対策**: 該当箇所のコードに、なぜEager Loadingを適用しているのか、その背景と注意点をコメントとして明記します。また、定期的なパフォーマンス監視で、クエリ数が異常に増加していないかをチェックする仕組みを導入します。
---
```

---
### 練習問題2

**【シチュエーション】**
技術的なリスクも洗い出され、提案はほぼ完璧になりました。最後に高橋さんは、この改善作業のチケット（タスク）を作成し、チームのタスク管理ツール（Jiraなど）に登録しようとしています。チケットには、**「このタスクが完了したと見なせる条件（完了の定義）」**を明確に記載する必要があります。彼はまず、AIに完了の定義の案を作成させました。

**▼ AIが作成した「完了の定義」（初稿）**
> - Eager Loadingを実装する。
> - パフォーマンスが改善されたことを確認する。

この定義を見た高橋さんは、「これでは曖-昧すぎて、人によって解釈が分かれてしまう。レビューする人も困るだろう」と考えました。

さあ、実際にChatGPTやGeminiなどの対話AIを使い、この**曖昧な完了の定義を、誰が見ても明確な定義に改善させる**自己検証プロンプトを作成してみましょう。

### Hint
自己検証は、文章の「曖昧さ」を排除し、具体性を高めるためにも使えます。今回は、AIに**「あなた自身がこのチケットのレビュー担当者だとしたら、この『完了の定義』のどこが曖-昧で、作業完了を判断できませんか？」**と問いかけてみましょう。AIに自身の回答の「曖昧な点」を自己指摘させることで、AIは「何を具体的にすれば良いか」を理解し、「パフォーマンス改善とは、具体的に何秒短縮されることか？」「コードレビューで何を確認すれば良いのか？」といった、客観的に判断可能な、より明確な定義を提案してくれます。

**▼ プロンプト例**
```
この「完了の定義」案を作成してくれてありがとうございます。
しかし、これではまだ定義が曖-昧です。

あなた自身が、このタスクのコードレビューを担当するエンジニアだと想像してください。
この「完了の定義」を見て、「これでは作業が完了したか判断できない」と感じるであろう曖昧な点を2つ挙げてください。
その上で、誰が見ても客観的に完了を判断できるような、具体的で測定可能な「完了の定義」に書き換えてください。
```

**▼ AIによる出力例**
```
承知いたしました。レビュー担当者の視点で、完了の定義の曖-昧さを指摘し、改善します。

### 「完了の定義」（初稿）の曖昧な点

1.  **「Eager Loadingを実装する」**: どの範囲のコードに、どのように実装すれば完了なのかが不明確です。
2.  **「パフォーマンスが改善されたことを確認する」**: 「改善」の基準が主観的で、定量的に判断できません。

### 「完了の定義」（改善案）

上記の点を踏まえ、以下のように具体的かつ測定可能な定義に修正します。

---
**完了の定義 (Definition of Done)**

- **[測定]** 負荷試験環境において、`/api/v1/translate`エンドポイントの平均レスポンスタイムが、現状の`X秒`から`Y秒`以下に短縮されていること。
- **[測定]** 上記の負荷試験中に、APMツールで観測されるDBクエリの発行数が、リクエストあたり`N+1`回から`2`回以下に削減されていること。
- **[確認]** 実装されたコードが、チームのコーディング規約に準拠しており、テックリードによるコードレビューで承認されていること。
- **[確認]** 関連するユニットテストがすべて成功（Pass）していること。
---
```

---
お疲れ様でした。これでワーク3は終了です。
次のセクションでは、この章で学んだ3つの高度なスキルを総動員し、高橋さんと田中さんの最終的な改善提案を完成させる、最高のプロンプトを作成する実践課題に挑戦しましょう。
