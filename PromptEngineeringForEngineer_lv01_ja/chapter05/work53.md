---
seq: 59
title: 懸念をAI自身に検証させる
slug: chapter05/work53
description: 技術的なリスクに対する懸念をAI自身に検証させる自己検証プロンプト
type: exercise
relation: chapter05/work42
difficulty: 3
displayLanguage: ja
duration: 20
---

# 懸念をAI自身に検証させる
## 練習問題
:::exercise
**【シチュエーション】**
非エンジニアにも分かりやすい説明になり、高橋さんは満足しました。しかし、今度はチームのシニアエンジニアからの、より技術的な視点でのツッコミが気になり始めました。「Eager Loadingは便利だけど、使い方を間違えると逆にパフォーマンスが悪化することもある。そのリスクは考慮しているのか？」といった指摘が来るかもしれません。

さあ、実際にChatGPTやGeminiなどの対話AIを使い、この**技術的なリスクに対する懸念を、AI自身に検証させる**自己検証プロンプトを作成してみましょう。
:::

:::hint
ここでも、批判的なペルソナを与えることが有効です。今回は「**コードの品質と長期的な保守性に非常に厳しいベテランのテックリード**」という役割を与えてみましょう。このペルソナは、提案された解決策の「良い面」だけでなく、「潜在的な副作用」や「将来の負債になる可能性」に目を光らせるはずです。「このEager Loadingという解決策を導入する際に、技術的に注意すべき潜在的な落とし穴を3つ挙げ、それぞれに対する予防策を追記するように」と指示することで、よりリスクを考慮した、信頼性の高い提案に進化させることができます。
:::

<details>
<summary>プロンプト例</summary>

```
ありがとうございます。非常に分かりやすくなりました。
最後に、技術的な観点からのレビューをお願いします。

あなたは、コードの品質と長期的な保守性に非常に厳しい、ベテランのテックリードです。
先ほどあなたが修正した提案書を読み、「Eager Loading」という解決策を導入する際に、技術的に注意すべき「潜在的な落とし穴」を3つ指摘してください。
そして、その落とし穴を避けるための具体的な対策を、提案書に追記する形で示してください。
```

**▼ AIによる出力例**
```
承知いたしました。テックリードとして、Eager Loading導入の潜在的な落とし穴と、その対策を指摘します。提案書に以下のセクションを追記することを推奨します。

### **4. 導入時に考慮すべき技術的リスクと対策**

Eager Loadingは強力な解決策ですが、導入には以下の点に注意が必要です。

**リスク1: 過剰なデータ取得（オーバーフェッチ）**
- **落とし穴**: 必要以上の関連データまで一括で取得してしまい、メモリ使用量が増大し、かえってパフォーマンスが悪化する可能性があります。
- **対策**: 取得する関連データを必要最小限に絞り込みます。また、コードレビュー時には、取得対象のデータ範囲が適切か、必ず確認するプロセスを設けます。

**リスク2: 複雑なクエリの生成**
- **落とし穴**: 複数の深い階層の関連を一度に取得しようとすると、ORMが非常に複雑で非効率なSQLクエリを生成してしまうことがあります。
- **対策**: Eager Loadingを適用するのは、原則として1階層から2階層までの関連に限定します。それ以上に複雑な場合は、クエリを分割するか、別の最適化手法を検討します。

**リスク3: 仕様変更への追従漏れ**
- **落とし穴**: 将来的に関連データの持ち方が変更された際に、Eager Loading部分の修正を忘れ、意図せずN+1クエリが再発する可能性があります。
- **対策**: 該当箇所のコードに、なぜEager Loadingを適用しているのか、その背景と注意点をコメントとして明記します。また、定期的なパフォーマンス監視で、クエリ数が異常に増加していないかをチェックする仕組みを導入します。
```
</details>
