---
seq: 40
title: 設計書作成
slug: chapter04/work27
description: AIを活用した効率的な設計書作成のテクニックを学ぶ
type: work
relation: chapter04/index,chapter04/work24
difficulty: 3
displayLanguage: ja
duration: 10
---

# 設計書作成

:::sample-quiz
## サンプル課題
ワーク1で技術選定を終えたソフトウェアエンジニアの高橋さん。次に、チームメンバーに実装のイメージを共有するため、簡単な設計書の作成に取り掛かりましたが、またもや手が止まってしまいます。

> **高橋さんのお悩み:**
> 「使う技術はDeepL APIに決まった。でも、この機能を実装するために、どんなデータをデータベースに保存する必要があるのか、どんなAPIエンドポイントを用意すればいいのか、具体的な設計書の草案をゼロから考えるのは時間がかかる。たたき台だけでもAIに作ってもらえないだろうか…。」

このような、曖昧な要件から具体的な設計書の草案を作成するタスクも、AIの得意分野です。AIを使って、高橋さんの設計業務を加速させましょう。
:::

## 解説

### AIは設計の「アシスタントアーキテクト」

AIは、一般的なアプリケーションの設計パターンを学習しているため、機能要件を伝えるだけで、データベースのテーブル設計やAPI仕様といった設計書の草案を高速で生成できます。

- **設計のたたき台作成**: ゼロから考える手間を省き、設計の初期案を数分で得られます。
- **考慮漏れの洗い出し**: AIが生成した設計案を見ることで、「この項目も必要だった」といった考慮漏れに気づくきっかけになります。
- **多様なパターンの提示**: 「この要件なら、こんな設計も考えられます」と代替案を提示させ、より良い設計を検討する手助けになります。

成功の鍵は、AIに「設計して」と丸投げするのではなく、**「どんな機能のための」「どんな要素を」「どんな形式で」**設計してほしいのかを具体的に指示することです。

:::Point
### AIの生成物はあくまで「草案」
AIが生成する設計書は、あくまで一般的なパターンに基づいた「草案」です。正規化やパフォーマンス、セキュリティといった非機能要件が十分に考慮されていない場合があります。AIの生成物をたたき台として、必ず経験豊富なエンジニアがレビューし、プロジェクトの要件に合わせて磨き上げることが不可欠です。
:::

:::Warning
AIは時として、プロジェクトの文脈や既存の設計ルールを無視した提案をすることがあります。生成された内容を鵜呑みにせず、「なぜこの設計なのか？」を常に考え、自社の標準に合わせて修正・改善する視点を持ちましょう。
:::

## サンプル課題解答

```markdown
あなたは、スケーラブルなWebアプリケーションの設計経験が豊富な、シニアソフトウェアアーキテクトです。
現在、自社システムに「リアルタイム翻訳機能」を組み込むためのバックエンド設計を行っています。

この機能を実装するために必要となる、以下の2つの設計書の草案を、具体的な理由や説明を添えて作成してください。

# 設計を依頼する項目
1.  **データベースのテーブル設計**: 翻訳の履歴を保存するためのテーブルを1つ設計してください。テーブル定義はMarkdown形式でお願いします。
2.  **APIエンドポイントの設計**: 翻訳を実行するためのAPIエンドポイントを1つ設計してください。仕様はリスト形式で記述してください。
```

**▼ AIによる出力例**

```markdown

承知いたしました。シニアソフトウェアアーキテクトとして、「リアルタイム翻訳機能」の設計書の草案を作成します。

### 1. データベーステーブル設計（翻訳履歴）

翻訳リクエストの履歴を管理するため、`translation_logs`テーブルを設計します。これにより、利用状況の分析や、将来的なユーザーごとの利用制限などに活用できます。

**テーブル名: `translation_logs`**

| カラム名          | データ型         | 制約                  | 説明                                   |
| ----------------- | ---------------- | --------------------- | -------------------------------------- |
| `id`              | `BIGINT`         | `PRIMARY KEY`, `AUTO_INCREMENT` | ログの一意なID                         |
| `user_id`         | `BIGINT`         | `NOT NULL`, `FOREIGN KEY`       | 翻訳機能を利用したユーザーのID         |
| `original_text`   | `TEXT`           | `NOT NULL`            | 翻訳元のテキスト                       |
| `translated_text` | `TEXT`           | `NOT NULL`            | 翻訳後のテキスト                       |
| `source_language` | `VARCHAR(10)`    | `NOT NULL`            | 翻訳元の言語コード（例: `JA`）         |
| `target_language` | `VARCHAR(10)`    | `NOT NULL`            | 翻訳先の言語コード（例: `EN`）         |
| `created_at`      | `TIMESTAMP`      | `NOT NULL`, `DEFAULT CURRENT_TIMESTAMP` | ログの作成日時                         |

### 2. APIエンドポイント設計

クライアント（フロントエンド）から翻訳リクエストを受け付けるためのAPIエンドポイントを設計します。

- **エンドポイント**: `POST /api/v1/translate`
- **説明**: 指定されたテキストを翻訳し、結果を返却します。
- **認証**: 要（リクエストヘッダーに認証トークンを含める）
- **リクエストボディ (JSON)**:

  {
    "text": "こんにちは、世界！",
    "source_lang": "JA",
    "target_lang": "EN"
  }

- **成功レスポンス (200 OK)**:

  {
    "translated_text": "Hello, world!"
  }

- **エラーレスポンス**:
  - `400 Bad Request`: リクエストの形式が不正な場合（必須パラメータの欠損など）
  - `401 Unauthorized`: 認証に失敗した場合
  - `500 Internal Server Error`: サーバー内部または翻訳APIでエラーが発生した場合

```

