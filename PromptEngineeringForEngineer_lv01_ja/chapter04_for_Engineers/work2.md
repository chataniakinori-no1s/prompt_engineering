---
seq: 23
title: ワーク2: 設計書作成
slug: chapter04_for_Engineers/work2
description: AIを活用した効率的な設計書作成のテクニックを学ぶ
type: work
relation: chapter04_for_Engineers/index,chapter04_for_Engineers/work1
difficulty: 3
displayLanguage: ja
duration: 30
---

# ワーク2: 設計書作成

## サンプル課題
ワーク1で技術選定を終えたソフトウェアエンジニアの高橋さん。次に、チームメンバーに実装のイメージを共有するため、簡単な設計書の作成に取り掛かりましたが、またもや手が止まってしまいます。

> **高橋さんのお悩み:**
> 「使う技術はDeepL APIに決まった。でも、この機能を実装するために、どんなデータをデータベースに保存する必要があるのか、どんなAPIエンドポイントを用意すればいいのか、具体的な設計書の草案をゼロから考えるのは時間がかかる。たたき台だけでもAIに作ってもらえないだろうか…。」

このような、曖昧な要件から具体的な設計書の草案を作成するタスクも、AIの得意分野です。AIを使って、高橋さんの設計業務を加速させましょう。

## 解説

### AIは設計の「アシスタントアーキテクト」

AIは、一般的なアプリケーションの設計パターンを学習しているため、機能要件を伝えるだけで、データベースのテーブル設計やAPI仕様といった設計書の草案を高速で生成できます。

- **設計のたたき台作成**: ゼロから考える手間を省き、設計の初期案を数分で得られます。
- **考慮漏れの洗い出し**: AIが生成した設計案を見ることで、「この項目も必要だった」といった考慮漏れに気づくきっかけになります。
- **多様なパターンの提示**: 「この要件なら、こんな設計も考えられます」と代替案を提示させ、より良い設計を検討する手助けになります。

成功の鍵は、AIに「設計して」と丸投げするのではなく、**「どんな機能のための」「どんな要素を」「どんな形式で」**設計してほしいのかを具体的に指示することです。

:::_ Point(AIの生成物はあくまで「草案」)
AIが生成する設計書は、あくまで一般的なパターンに基づいた「草案」です。正規化やパフォーマンス、セキュリティといった非機能要件が十分に考慮されていない場合があります。AIの生成物をたたき台として、必ず経験豊富なエンジニアがレビューし、プロジェクトの要件に合わせて磨き上げることが不可欠です。
:::

#### Warning
AIは時として、プロジェクトの文脈や既存の設計ルールを無視した提案をすることがあります。生成された内容を鵜呑みにせず、「なぜこの設計なのか？」を常に考え、自社の標準に合わせて修正・改善する視点を持ちましょう。

### サンプル課題解答
```
あなたは、スケーラブルなWebアプリケーションの設計経験が豊富な、シニアソフトウェアアーキテクトです。
現在、自社システムに「リアルタイム翻訳機能」を組み込むためのバックエンド設計を行っています。

この機能を実装するために必要となる、以下の2つの設計書の草案を、具体的な理由や説明を添えて作成してください。

# 設計を依頼する項目
1.  **データベースのテーブル設計**: 翻訳の履歴を保存するためのテーブルを1つ設計してください。テーブル定義はMarkdown形式でお願いします。
2.  **APIエンドポイントの設計**: 翻訳を実行するためのAPIエンドポイントを1つ設計してください。仕様はリスト形式で記述してください。
```

**▼ AIによる出力例**
```
承知いたしました。シニアソフトウェアアーキテクトとして、「リアルタイム翻訳機能」の設計書の草案を作成します。

### 1. データベーステーブル設計（翻訳履歴）

翻訳リクエストの履歴を管理するため、`translation_logs`テーブルを設計します。これにより、利用状況の分析や、将来的なユーザーごとの利用制限などに活用できます。

**テーブル名: `translation_logs`**

| カラム名          | データ型         | 制約                  | 説明                                   |
| ----------------- | ---------------- | --------------------- | -------------------------------------- |
| `id`              | `BIGINT`         | `PRIMARY KEY`, `AUTO_INCREMENT` | ログの一意なID                         |
| `user_id`         | `BIGINT`         | `NOT NULL`, `FOREIGN KEY`       | 翻訳機能を利用したユーザーのID         |
| `original_text`   | `TEXT`           | `NOT NULL`            | 翻訳元のテキスト                       |
| `translated_text` | `TEXT`           | `NOT NULL`            | 翻訳後のテキスト                       |
| `source_language` | `VARCHAR(10)`    | `NOT NULL`            | 翻訳元の言語コード（例: `JA`）         |
| `target_language` | `VARCHAR(10)`    | `NOT NULL`            | 翻訳先の言語コード（例: `EN`）         |
| `created_at`      | `TIMESTAMP`      | `NOT NULL`, `DEFAULT CURRENT_TIMESTAMP` | ログの作成日時                         |

### 2. APIエンドポイント設計

クライアント（フロントエンド）から翻訳リクエストを受け付けるためのAPIエンドポイントを設計します。

- **エンドポイント**: `POST /api/v1/translate`
- **説明**: 指定されたテキストを翻訳し、結果を返却します。
- **認証**: 要（リクエストヘッダーに認証トークンを含める）
- **リクエストボディ (JSON)**:
  ```json
  {
    "text": "こんにちは、世界！",
    "source_lang": "JA",
    "target_lang": "EN"
  }
  ```
- **成功レスポンス (200 OK)**:
  ```json
  {
    "translated_text": "Hello, world!"
  }
  ```
- **エラーレスポンス**:
  - `400 Bad Request`: リクエストの形式が不正な場合（必須パラメータの欠損など）
  - `401 Unauthorized`: 認証に失敗した場合
  - `500 Internal Server Error`: サーバー内部または翻訳APIでエラーが発生した場合
```

---
### 練習問題1
**【シチュエーション】**
高橋さんはAIが作成した設計書の草案をチームリーダーに見せたところ、「良い出発点だね。ただ、どの翻訳APIを使ったのか記録しておかないと、将来的に別のAPIを追加した時に分析できないよ。あと、APIは文字数で課金されるから、コスト管理のために翻訳した文字数も記録しておこう」というフィードバックをもらいました。

さあ、AIへの指示を修正して、**このフィードバックを反映したデータベーステーブル設計**を再度作成させてみましょう。

### Hint
AIとの対話は一回で終わりではありません。**第2章で学んだように、最初の出力に対して追加の要件や修正点を具体的にフィードバックする**ことで、設計をより洗練させることができます。「先ほどのテーブル設計に、〇〇と△△のカラムを追加して」のように、変更点を明確に指示するのがコツです。

### 練習問題1プロンプト例
```
あなたは、先ほど「リアルタイム翻訳機能」の設計を行ったソフトウェアアーキテクトです。
先ほどの`translation_logs`テーブルの設計に、以下の2つの要件を追加で反映させて、更新版のテーブル設計をMarkdown形式で作成してください。

# 追加要件
1.  **使用した翻訳サービスを記録する**: 将来的に複数の翻訳APIを使い分ける可能性を考慮し、どのサービス（例: 'DeepL', 'Google'）を利用したかを保存するカラムを追加してください。
2.  **翻訳文字数を記録する**: コスト管理のため、翻訳した原文の文字数を保存するカラムを追加してください。
```

### 練習問題1AI回答出力例
（AIによる回答のイメージ）
```
承知いたしました。フィードバックを反映し、`translation_logs`テーブルの設計を更新します。

**テーブル名: `translation_logs` (v2)**

| カラム名            | データ型         | 制約                  | 説明                                   |
| ------------------- | ---------------- | --------------------- | -------------------------------------- |
| `id`                | `BIGINT`         | `PRIMARY KEY`, `AUTO_INCREMENT` | ログの一意なID                         |
| `user_id`           | `BIGINT`         | `NOT NULL`, `FOREIGN KEY`       | 翻訳機能を利用したユーザーのID         |
| `original_text`     | `TEXT`           | `NOT NULL`            | 翻訳元のテキスト                       |
| `translated_text`   | `TEXT`           | `NOT NULL`            | 翻訳後のテキスト                       |
| `source_language`   | `VARCHAR(10)`    | `NOT NULL`            | 翻訳元の言語コード（例: `JA`）         |
| `target_language`   | `VARCHAR(10)`    | `NOT NULL`            | 翻訳先の言語コード（例: `EN`）         |
| `service_provider`  | `VARCHAR(50)`    | `NOT NULL`            | 利用した翻訳サービス名（例: `DeepL`）  |
| `character_count`   | `INT`            | `NOT NULL`            | 翻訳した原文の文字数                   |
| `created_at`        | `TIMESTAMP`      | `NOT NULL`, `DEFAULT CURRENT_TIMESTAMP` | ログの作成日時                         |
```

---
### 練習問題2
**【シチュエーション】**
チームでさらに議論した結果、「専門用語の翻訳精度を上げるために、ユーザーが独自の用語集を登録できる機能も追加しよう」という話になりました。これを実現するには、`translation_logs`とは別に、用語集を管理するための新しいデータベーステーブルが必要そうです。

さあ、AIに**用語集を管理するための新しいテーブル設計**を依頼するプロンプトを作成してみましょう。

### Hint
新しい機能には新しいテーブルが必要です。**「誰が（ユーザー）」「何を（用語集）」**管理するのか、その関係性をAIに伝えることが重要です。今回は、「1人のユーザーが、複数の用語ペア（翻訳元と翻訳後）を登録できる」という関係性を考慮したテーブル設計を依頼してみましょう。

### 練習問題2プロンプト例
```
あなたは、引き続き「リアルタイム翻訳機能」の設計を担当するソフトウェアアーキテクトです。
新たに追加される「ユーザー辞書（用語集）」機能を実装するため、データベース設計を拡張する必要があります。

以下の要件を満たす、新しいテーブルの設計をMarkdown形式で作成してください。

# 要件
- ユーザーが独自の「翻訳元の単語」と「翻訳先の単語」のペアを登録できるようにする。
- どのユーザーが登録した用語集なのかを管理できるようにする。
```

### 練習問題2AI回答出力例
（AIによる回答のイメージ）
```
承知いたしました。「ユーザー辞書」機能のための新しいテーブルを設計します。ユーザーと用語集エントリは1対多の関係になるため、以下のようなテーブルが適切です。

**テーブル名: `user_glossary_entries`**

| カラム名        | データ型         | 制約                  | 説明                                   |
| --------------- | ---------------- | --------------------- | -------------------------------------- |
| `id`            | `BIGINT`         | `PRIMARY KEY`, `AUTO_INCREMENT` | 用語集エントリの一意なID               |
| `user_id`       | `BIGINT`         | `NOT NULL`, `FOREIGN KEY`       | このエントリを所有するユーザーのID     |
| `source_term`   | `VARCHAR(255)`   | `NOT NULL`            | 翻訳元の単語                           |
| `target_term`   | `VARCHAR(255)`   | `NOT NULL`            | 翻訳先の単語                           |
| `created_at`    | `TIMESTAMP`      | `NOT NULL`, `DEFAULT CURRENT_TIMESTAMP` | エントリの作成日時                     |
| `updated_at`    | `TIMESTAMP`      | `NOT NULL`, `DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP` | エントリの最終更新日時                 |

**補足:**
`user_id`と`source_term`に複合ユニーク制約を設けることで、同一ユーザーが同じ単語を重複して登録することを防ぐ設計も考えられます。
```

---
お疲れ様でした。これでこのワークは終了です。
次のワークでは、AIを使って、システムが吐き出す大量のログを分析し、エラーの原因を特定する方法について学んでいきましょう。
