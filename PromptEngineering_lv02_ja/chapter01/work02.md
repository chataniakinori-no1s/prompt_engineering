---
seq: 3
title: 初めてのチャットボット作成と基本操作
slug: chapter01/work02
description: Difyを使用してシンプルなチャットボットを作成し、AIに役割を与える方法を学ぶ
type: work
difficulty: 2
displayLanguage: ja
duration: 15
---

# 初めてのチャットボット作成と基本操作

前回はDifyを動かすための環境を準備し、Geminiモデルの無料APIキーをセットしました。いよいよこれから、実際にアプリケーションを構築していきます。

まずはDifyの基本的な仕組みを理解するために、シンプルなチャットボットを作成し、AIに特定の役割（キャラクター）を与えるカスタマイズに挑戦してみましょう。この演習を通じて、AIアプリケーション開発の第一歩を踏み出します。

## Difyの基本を理解しよう

アプリケーション作成を始める前に、Difyの基本的な考え方をいくつか学びましょう。

#### Difyのアプリタイプ

Difyでは、作りたいものに応じていくつかの「アプリタイプ」が用意されています。これらは、処理の複雑さやユーザーとの対話形式によって、大きく「**基本的なアプリタイプ**」と「**高度なアプリタイプ**」に分かれています。

* **基本的なアプリタイプ**(初心者向け)
    * **チャットボット**: 1対1の対話形式で応答するシンプルなアプリ。
    * **テキストジェネレーター**: フォームに一度入力すると、1つの結果を返すアプリ。
    * **エージェント**: ユーザーの指示に応じて、Difyに登録されたツールを自動で選んで実行する賢い対話型アプリ。

* **高度なアプリタイプ**(上級者向け)
    * **チャットフロー**: 複数の処理（ノード）を繋ぎ合わせ、複雑な対話の流れを設計できる。
    * **ワークフロー**: 複数の処理を連携させ、一度の実行で完結させる自動化処理を設計できる。

単純な要約アプリなら基本的なアプリタイプで十分ですが、「文章量に応じて処理を変える」「複数のAIに役割を与える」といった複雑なことをするには、**チャットフロー**や**ワークフロー**が必要です。

この講座では、応用範囲が広く、業務自動化の核となる**チャットフロー**と**ワークフロー**を中心に学んでいきます。それらを学ぶことで基本的な機能の大部分をカバーできるため、Difyで実現できることの幅が大きく広がります。

#### 変数とは？

Difyでフローをつくる上で欠かせないのが「**変数**」の概念です。変数は、データを一時的に保存しておくための「**箱**」だと考えてください。

例えば、ユーザーがチャットで入力した「こんにちは」というテキスト。このテキストは `sys.query` という名前の変数（箱）に自動的に格納されます。後の処理でこの箱の名前を指定することで、中身（「こんにちは」というテキスト）を取り出して利用できる、という仕組みです。

#### システム変数

Difyには、あらかじめ用意されている「**システム変数**」があります。これらは `sys.` から始まり、アプリケーションの実行状態に関する情報が自動で格納されます。

* `sys.query`: ユーザーが入力した最新のテキスト。最もよく使います。
* `sys.files`: ユーザーがアップロードしたファイル。
* `sys.dialogue_count`: ユーザーとの会話が何往復目かを示す数字。

これらの変数を使いこなすことで、アプリケーションの挙動を細かくコントロールできます。

---

### 実践：初めてのチャットボットを動かしてみよう

それでは、実際にDifyを操作して、最初のチャットフローを作っていきます。目標は、AIに「犬のキャラクター」という役割を与え、そのキャラクターになりきって応答させることです。

#### Step 1: 新しいチャットフローの作成

1.  Difyのスタジオページを開き`[最初から作成]`を選択します。
![](https://chataniakinori-no1s.github.io/prompt_engineering/PromptEngineering_lv02_ja/assets/chapter01/img/work2-1.png)
2.  アプリタイプとして `[チャットフロー]` を選び、アプリ名に「初めてのチャットボット」と入力し、`[作成する]` ボタンを押します。
![](https://chataniakinori-no1s.github.io/prompt_engineering/PromptEngineering_lv02_ja/assets/chapter01/img/work2-2.png)
  
すると、3つのブロック（**ノード**）が線で繋がった開発画面が表示されます。これがチャットフローの基本形です。
![](https://chataniakinori-no1s.github.io/prompt_engineering/PromptEngineering_lv02_ja/assets/chapter01/img/work2-3.png)

* **開始**: ユーザーからの入力を受け取る入り口です。
* **LLM**: AIに処理を依頼する窓口です。
* **回答**: 処理結果をユーザーに表示する出口です。

#### Step 2: LLMノードをカスタマイズする

次に、AIに特定の役割を与えるための指示（プロンプト）を設定します。

1.  中央にある `LLM`ノードをクリックして、設定パネルを開きます。
![](https://chataniakinori-no1s.github.io/prompt_engineering/PromptEngineering_lv02_ja/assets/chapter01/img/work2-4.png)

2.  **モデル選択**: Work1で設定したGoogleの `Gemini` モデルを選択します。（例: `gemini-2.5-flash`）
3.  **プロンプト設定**: `SYSYEM`には、AIに常に見てもらいたい「前提となる指示」や「役割設定」を書き込みます。
    > SYSTEMに設定するプロンプト、つまり`システムプロンプト`は、第2章で学んだ**プロンプトの基本作法「役割設定（ペルソナ）」**の実践です。AIにあらかじめ「あなたは〇〇です」という明確な役割を与えることで、その後の回答すべてに一貫性を持たせ、キャラクターを演じさせることができます。
4.  `SYSTEM` の入力欄に、以下の文章をコピー＆ペーストしてください。
```
あなたは親しみやすい犬のキャラクター「ワン太」です。
すべての回答の語尾に「〜わん」と付けて、可愛らしく回答してください。
ただし回答は50字以内に抑えること。
```
![](https://chataniakinori-no1s.github.io/prompt_engineering/PromptEngineering_lv02_ja/assets/chapter01/img/work2-5.png)

5.  `USER`の欄には、ユーザーの入力内容を`{{sys.query}}`や`{{sys.files}}`という変数の箱につめてAIに渡すよう自動で設定されています。
これは「ユーザーが入力した質問とファイルをそのままAIに渡す」という意味なので、今回は変更不要です。

これで、「ワン太として振る舞い、ユーザーの質問に答える」という指示が完成しました。

#### Step 3: テストと実行

設定が正しく機能するか、プレビュー機能を使って試してみましょう。

1.  画面右上の `[プレビュー]` ボタンを押すと、右側にチャット画面が表示されます。
![](https://chataniakinori-no1s.github.io/prompt_engineering/PromptEngineering_lv02_ja/assets/chapter01/img/work2-6.png)
2.  下のメッセージ入力欄に、何か簡単な質問（例: `日本の首都はどこ？`）を入力して送信します。

3.  左側の開発画面で、`開始` → `LLM` → `回答` の順にノードが光り、処理が流れていく様子がわかります。
4.  右側のチャット画面に、「日本の首都は東京だわん！」といったように、犬のキャラクターとして回答が返ってきたら成功です！
![](https://chataniakinori-no1s.github.io/prompt_engineering/PromptEngineering_lv02_ja/assets/chapter01/img/work2-7.png)


#### Step 4: 会話の記憶 - 「メモリ」機能の役割
AIは学習したデータから次に来る単語を予測して回答を生成するため、人間のように「直前の会話」を覚えて回答するわけではありません。これでは自然な会話は成り立ちませんね。このステップでは、AIに会話の文脈を記憶させる**「メモリ」**機能について学びます。

AIに会話の記憶を持たせる設定を行いましょう。

1.  `LLM` ノードの設定パネルを開きます。
2.  設定項目の中から**`メモリ`**というトグルスイッチを見つけ、**ON**にしてください。
3.  プレビュー画面のチャットで以下のように、連続して質問を投げかけてみましょう。
    * **あなた**: `日本の首都はどこ？`
    * **AIの応答（予想）**: `日本の首都は東京だわん！`
    * **あなた**: `そこって人口はどれぐらい？`
4.  AIが最後の質問にどう答えるか、観察してください。「東京の人口は○○だわん！」のように、**「そこ」が東京であることを理解した上で**、質問に答えてくれるはずです。
![](https://chataniakinori-no1s.github.io/prompt_engineering/PromptEngineering_lv02_ja/assets/chapter01/img/work2-8.png)

:::point
**メモリ機能がOFFの状態だと、AIはこれまでの会話を参照しません。**
AIにとっては、毎回が「初めまして」の状態であり、「そこの天気」と言われても、「そこ」が「東京」を指しているとは理解できません。一つ一つの対話が完全に独立しているのです。
:::

これがメモリ機能の効果です。ONにすると、Difyは過去の会話履歴をAIへの入力に自動で含めるようになり、AIは文脈を考慮した自然な応答が可能になります。

---
:::warning
### 【注意点】メモリウィンドウサイズとコスト ⚠️
メモリ機能をONにすると**「メモリウィンドウサイズ」**という設定項目が現れます。これは非常に重要な設定です。

* **メモリウィンドウサイズとは？**: AIが記憶として参照する**直近の会話の往復数**を指します。（ユーザーの発言＋AIの応答＝1往復）
    * 例えば「3」に設定すると、AIは常に直近3往復分の会話を思い出しながら次の応答を考えます。
* **トレードオフを理解しよう**:
    * **ウィンドウサイズを大きくする**:
        * **メリット**: 長い文脈を理解できるようになり、より複雑な会話に対応できます。
        * **デメリット**: 過去の会話をすべてAPIに送信するため、**APIの利用料金が増加し、応答速度も遅くなります**。
    * **ウィンドウサイズを小さくする**:
        * **メリット**: コストを抑え、応答速度を速く保てます。
        * **デメリット**: 少し前の会話を忘れてしまい、文脈を見失うことがあります。

**【推奨】**
まずは**3〜5程度の小さなウィンドウサイズから始める**のがおすすめです。アプリケーションの目的に合わせて、必要な記憶力とコスト、速度のバランスが取れる最適な値を探っていくのが、実践的な開発のポイントです。
:::

---

お疲れ様でした！ これで、あなたはDifyの基本的なチャットフローを構築し、AIに特定の役割を与えるチャットボットを作り上げることができました。

このチャットボットをもとに、次のWork3では、AIに外部の知識（ファイルやドキュメント）を読み込ませる、より実践的な「RAG」という技術を学んでいきます。
