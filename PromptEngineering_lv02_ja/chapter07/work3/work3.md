### ワーク3: 設計書の自動生成とWord(DOCX)ドキュメントへの保存

Work2では、AIが自律的に技術調査を行い、その結果を後続の処理で利用しやすいように整形するワークフローの「情報収集フェーズ」を完成させました。しかし、高橋さんの最終ゴールである「設計書の作成」と「成果物の保存」にはまだ至っていません。

このWork3では、いよいよパイプラインを完成させます。複数のLLMを連携させる「**LLMチェーン**」と、成果物の品質を条件が満たされるまで反復的に向上させる「**ループ**」という高度なテクニックを駆使。収集した情報を**分析・要約**し、その結果を基に**設計書を生成**、さらに完成した設計書を**Microsoft Word (DOCX) ドキュメントに自動で変換・保存**するまでを一気通貫で自動化します。

---
### LLMチェーンとループによる品質向上

このワークの鍵は、複数のLLMと外部ツールを「チェーン（鎖）」のように繋ぎ、それぞれに専門的な役割を与えることです。

#### LLMチェーンとは？

一つのLLMに全ての作業を任せるのではなく、役割分担させることで最終的なアウトプットの質を劇的に向上させる手法です。

* **リサーチ戦略LLM (Work2で作成)**: 要件定義書から、調査すべき「問い」を生成する戦略家。
* **分析・要約LLM (今回作成)**: Tavily Searchの結果という生の情報を読み解き、核心だけを抽出するアナリスト。
* **設計書執筆LLM (今回作成)**: 元の要件と分析結果、そしてレビュー結果を基に設計書を執筆・修正するライター。
* **設計書レビューLLM (今回作成)**: 執筆された設計書を厳しく評価し、改善点を指摘するレビュアー。

#### ループによる反復的改善

「ループ」ノードを使うと、「**指定した条件が満たされるまで**」パイプライン内の処理を繰り返すことができます。今回はこれを利用して「**執筆→レビュー→（改善点があれば）→修正**」という、人間が行うような品質向上のためのフィードバックループを自動化します。レビューLLMからの指摘がなくなるまで、設計書は何度も推敲されます。

---
### 実践：設計書を自動生成し、Wordドキュメントに保存する

#### ✅ 実践の前に：DOCX変換ツールの準備をしよう

まず、マーケットプレイスからMarkdownテキストをMicrosoft Word (DOCX) 形式に変換するツールを追加します。

1.  Dify画面上部のメニューから `ツール` → `マーケットプレイス` を選択します。
2.  検索窓に「DOC」や「Word」などと入力し、`Markdown to DOCX Converter` を探します。
3.  表示された該当ツールの `追加` ボタンをクリックします。

---
#### Step 1: 調査結果を分析・要約する（分析LLM）

Work2の続きから始めます。Tavily Searchで得られた質の高い情報を、設計に使えるように整理・要約するLLMを追加します。

1.  Work2で作成したワークフローの最後の `コード` ノード（配列をフラットにしたノード）の次に、新しい `[LLM]` ノードを追加します。
2.  このLLMに「分析・要約」の役割を与えます。`システムプロンプト` に以下の指示を貼り付けます。
```prompt
# 役割
あなたは、膨大な技術文書から要点を瞬時に見抜く能力に長けた経験豊富なテックリードです。

# タスク
以下の「要件定義書」と「Web検索の結果」を精査し、後続のエンジニアが設計書を作成するために必要不可欠な技術的ポイント、採用すべきアーキテクチャのパターン、ベストプラクティス、そして潜在的なリスクを簡潔に要約してください。

# 制約条件
- 専門用語を正しく用い、具体的で実行可能な提言に絞り込むこと。
- 後続の設計書執筆AIが直接利用しやすいように、箇条書きで構造化して出力すること。
```
3.  `ユーザー入力` の欄に、`テキスト抽出`ノードの出力 `{{#テキスト抽出.text#}}` と、`コード実行（配列の整形）`ノードの出力 `{{#コード実行（配列の整形）.final_search_results#}}` のすべてを設定します。

---
#### Step 2: ループで設計書の品質を向上させる

「執筆→レビュー→修正」のフィードバックループを構築します。

1.  `分析LLM` の次に、`[ループ]` ノードを追加します。
2.  `ループ` ノードをクリックし、以下のように設定します。
    * **`ループ変数`**: `+` ボタンを押し、以下の2つの変数を定義します。
        1.  **変数名**: `draft_document`
            * **タイプ**: `String`
            * **モード**: `Constant`
            * **値**: **""（ダブルクオーテーション2つ）**を設定します。
        2.  **変数名**: `review_comments`
            * **タイプ**: `String`
            * **モード**: `Constant`
            * **値**: **""（ダブルクオーテーション2つ）**を設定します。
    * **`ループ終了条件`**:
        * `{{#LLM（修正）.text#}}` `含む` `指摘事項なし`
        * **解説**: ループ内のレビューLLMの出力に「指摘事項なし」という文字列が含まれた場合に、ループを終了させます。

---
#### Step 3: 設計書を執筆・修正する（執筆LLM @ループ内）

1.  ループ内の1つ目のLLMを「執筆LLM」とします。このLLMは、初回は分析結果から、2回目以降はレビュー結果を基に設計書を修正します。
2.  `システムプロンプト` に、設計書を作成・修正するための詳細な指示を貼り付けます。
```prompt
# 役割
あなたは、複雑な要件を明確で構造化された技術設計書に落とし込むことを得意とするシステムアーキテクトです。

# タスク
提供された「要件定義書」「分析・要約された技術情報」そして「前回のレビュー指摘事項」を基に、以下の形式でマークダウン形式のAPI設計書を作成または修正してください。
「前回のレビュー指摘事項」が空の場合は、新規に設計書を作成します。指摘事項がある場合は、それをすべて反映した上で、より完成度の高い設計書にしてください。

# 出力形式
## 1. 機能概要
（要件を基に記述）
## 2. APIエンドポイント
- Method: (GET/POST/PUT/DELETE)
- Path: /api/v1/...
## 3. リクエスト仕様
（ヘッダー、パスパラメータ、クエリパラメータ、リクエストボディなど）
## 4. レスポンス仕様
（成功時(200 OK)、エラー時(400, 500)のJSONレスポンス例など）
## 5. 採用技術とアーキテクチャ
（分析結果とレビュー指摘を基に、なぜその技術を選択したかの理由を明確に記述）
```
3.  `ユーザー入力` に、以下の3つを設定します。
    * 元の要件: `{{#開始.requirements_doc#}}`
    * 分析・要約された技術情報: `{{#ループ.item#}}` （ループの入力）
    * 前回のレビュー指摘事項: `{{#LLM（修正）.text#}}` （ループ内のレビューLLMの出力）

---
#### Step 4: 設計書をレビューする（レビューLLM @ループ内）

1.  ループ内の2つ目のLLMを「レビューLLM」とし、`執筆LLM` の後続に配置します。
2.  `システムプロンプト` に、第5章で学んだ**メタ認知プロンプト**を応用し、自己評価させる指示を与えます。
```prompt
# 役割
あなたは、設計書の些細な不備も見逃さない、品質に非常に厳しいプリンシパルエンジニアです。

# タスク
以下の「要件定義書」と、それに基づいて作成された「設計書ドラフト」をレビューしてください。
以下のチェックリストに基づき、具体的で建設的な改善点を最大3つ、箇条書きで指摘してください。
**もし改善点が一切なければ、必ず「指摘事項なし」とだけ出力してください。** この応答がループを終了させるトリガーになります。

# レビュー観点
- 要件網羅性: 元の要件がすべて満たされているか？
- 技術的妥当性: 提案されている技術選定やアーキテクチャは合理的か？
- 明確性: 曖昧な表現がなく、誰が読んでも一意に解釈できるか？
```
3.  `ユーザー入力` に、`テキスト抽出`ノードの出力 `{{#テキスト抽出.text#}}`と、`執筆LLM` の出力 `{{#LLM（執筆）.text#}}` の両方を設定します。

#### Step 5: ループの状態を更新する（変数代入ノード @ループ内）

このループで生成された「最新の設計書ドラフト」と「最新のレビューコメント」を、次のループが開始する前に**ループ変数の値を上書き**して記憶させます。

1.  ループ内の `レビューLLM` の次に、`変数代入` ノードを追加します。
2.  `変数`セクションで`+`を2回押し、以下のように設定します。
    * **1つ目**:
        * `変数`: `ループ.draft_document` を選択
        * `操作`: `上書き`
        * `値`: `執筆LLM` の出力 `{{#LLM（執筆）.text#}}` を設定
    * **2つ目**:
        * `変数`: `ループ.review_comments` を選択
        * `操作`: `上書き`
        * `値`: `レビューLLM` の出力 `{{#LLM（修正）.text#}}` を設定

#### Step 6: Word (DOCX) ドキュメントに変換して出力する

1.  `ループ` ノードの**外側**に、`[ツール]` から `[Markdown to DOCX Converter]` ノードを追加します。
2.  **DOCX変換ノードの設定**:
    * `markdown_text` (入力): `ループ` ノードの**出力** `{{#ループ.item#}}` を設定します。
    * `file_name` (出力ファイル名): 「設計書.docx」のように、任意のファイル名を入力します。
3.  `Markdown to DOCX Converter` ノードを `終了` ノードに接続します。
4.  `終了` ノードをクリックし、`[+ 出力変数を追加]` からDOCX変換ツールの出力（例: `{{#markdown_to_docx_1.file#}}`）を選択します。

---
#### Step 6: テストと実行

すべてのパイプラインが完成しました。プレビュー画面で最終動作を確認しましょう。

1.  `[実行]` をクリックし、要件定義書ファイルをアップロードして再度 `[実行]` します。
2.  左側の開発画面で、ループノードが何度か（レビューの指摘がなくなるまで）実行される様子を確認できます。
3.  処理が完了すると、出力欄にWord (DOCX) ファイルが生成され、ダウンロードできるようになります。ファイルを開き、推敲が重ねられた最終設計書が書き込まれていれば、大成功です。

お疲れ様でした！ これで、要件定義書のアップロードから、複数のAIによる協調作業と品質改善ループを経て、最終成果物をWordドキュメントとして自動生成する、極めて高度で実用的な自動化ワークフローが完成しました。