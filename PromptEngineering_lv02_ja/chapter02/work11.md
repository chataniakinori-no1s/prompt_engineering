---
seq: 13
title: 設計書の自動生成とWord(DOCX)ドキュメントへの保存
slug: chapter02/work11
description: LLMチェーンとループを活用し、設計書の自動生成からWordドキュメントへの保存までを一気通貫で実現する
type: work
difficulty: 3
displayLanguage: ja
duration: 40
relation: chapter02/work02,chapter02/work04
---

# 設計書の自動生成とWord(DOCX)ドキュメントへの保存

先ほどのワークでは、AIが技術調査を行い、データを整形するまでのフローを構築しました。高橋さんが求めている設計書の自動作成ワークフロー完成まで、あと少しです。

このワークで構築する残りのステップ
```
✅1. ユーザーがアップロードした「要件定義書」をAIに渡し、調査すべき問いをいくつかの観点で**考える**。

✅2. その問いをもとに**Tavily**ツールを使ってWeb上で**技術調査を行う**。

✅3. 検索結果をスコアでフィルタリングし、後続ノードに渡すデータを**整える**。

4. 「要件定義書」と「Web検索の結果」を精査し、設計書を作成するために必要不可欠な技術的ポイント、採用すべきアーキテクチャのパターン、潜在的なリスクなどを**分析**する。

5. 設計書の執筆と修正を**ループ実行する**。
```

検索したデータをもとにこのワークで設計書を作成していきますが、検索結果をそのまま設計書に反映するのは危険です。

もともとの要件と収集した情報をAIに渡して、設計書を作成するために必要不可欠な技術的ポイント、採用すべきアーキテクチャのパターン、ベストプラクティス、そして潜在的なリスクを**分析**し、簡潔に**要約**するステップをAIに踏ませましょう。

最後に要件と上記の分析結果をもとに設計書を執筆していきます。

一度きりの執筆では回答に揺らぎが出てしまうため、執筆役AIとレビュアー役AIを`ループ`ノード内で条件が満たされるまで反復的に実行し、完成した設計書を**Microsoft Word (DOCX) ドキュメントに自動で保存**するまでを一気通貫で自動化します。

## 実践：設計書を自動生成し、Wordドキュメントに保存する

### ✅ 実践の前に：DOCX変換ツールの準備をしよう

まず、マーケットプレイスからMarkdownテキストをMicrosoft Word (DOCX) 形式に変換するツールを追加します。

1.  Dify画面上部のメニューから `ツール` → `マーケットプレイス` を選択します。
2.  検索窓に「DOC」と入力し、`DOC` を探します。
![](https://chataniakinori-no1s.github.io/prompt_engineering/PromptEngineering_lv02_ja/assets/chapter02/img/work11-1.png)

3.  表示された該当ツールの `インストール` ボタンをクリックしてインストールします。
![](https://chataniakinori-no1s.github.io/prompt_engineering/PromptEngineering_lv02_ja/assets/chapter02/img/work11-2.png)

### Step 1: 調査結果を分析・要約する（分析LLM）

先ほどのワークで作成したワークフロー「自動調査&設計書作成」の続きから始めます。Tavily Searchで得られた質の高い情報と要件定義を照らし合わせて、設計書の作成に必要な情報を分析・要約する`LLM`ノードを追加します。

1.  `イテレーション` ノードの次に、新しい `[LLM]` ノードを追加します。
2.  このLLMに「分析・要約」の役割を与えます。`システムプロンプト` に以下の指示を貼り付けます。

```markdown 
# 役割
あなたは、膨大な技術文書から要点を瞬時に見抜く能力に長けた経験豊富なテックリードです。

# タスク
以下の「要件定義書」と「Web検索の結果」を精査し、後続のエンジニアが設計書を作成するために必要不可欠な技術的ポイント、採用すべきアーキテクチャのパターン、ベストプラクティス、そして潜在的なリスクを簡潔に要約してください。

# 制約条件
- 専門用語を正しく用い、具体的で実行可能な提言に絞り込むこと。
- 後続の設計書執筆AIが直接利用しやすいように、箇条書きで構造化して出力すること。
```

3.  `USER` の欄に、以下の変数すべてを設定します。
```
#要件定義
{テキスト抽出/text}
#検索結果
{イテレーション/output}
```
![](https://chataniakinori-no1s.github.io/prompt_engineering/PromptEngineering_lv02_ja/assets/chapter02/img/work11-3.png)

### Step 2: ループで設計書の品質を向上させる

「執筆↔レビュー」のフィードバックループを構築します。

1.  `LLM（分析・要約）`ノード の次に、`[ループ]` ノードを追加します。
![](https://chataniakinori-no1s.github.io/prompt_engineering/PromptEngineering_lv02_ja/assets/chapter02/img/work11-4.png)

2.  `ループ` ノードをクリックし、以下のように設定します。
    * **`ループ変数`**: `+` ボタンを押し、以下の2つの変数を定義します。
        1.  **変数名**: `draft_document`
            * **タイプ**: `String`
            * **モード**: `Constant`
            * **値**: **""（ダブルクオーテーション2つ）**を設定します。
        2.  **変数名**: `review_comments`
            * **タイプ**: `String`
            * **モード**: `Constant`
            * **値**: **""（ダブルクオーテーション2つ）**を設定します。
    * **ループ終了条件**はLLM（修正）ノードの出力内容を条件とするため、このあとノードを立ててから設定します。
![](https://chataniakinori-no1s.github.io/prompt_engineering/PromptEngineering_lv02_ja/assets/chapter02/img/work11-5.png)

:::point
ループ変数に`draft_document`を設定した理由は、`ループ`ノード内の出力を直接`DOC`ノードへ渡すことができない仕様のため、執筆した設計書をループ変数に持たせて`DOC`ノードで受け取る必要があるためです。
:::

## LLMチェーンとループによる品質向上

ここでの鍵は、ループノード内で複数のLLMノードを「チェーン（鎖）」のように繋ぎ、各LLMノードに専門的な役割を与えることです。

## LLMチェーンとは？

一つのLLMに全ての役割や作業を任せるのではなく、役割分担させることで最終的なアウトプットの質を向上させる手法です。

このワークで作成する複数のLLMノードは以下の3つです。

* **分析・要約LLM**: Tavily Searchの結果と要件定義を照らし合わせ、設計書作成に必要な核だけを抽出するアナリスト。
* **設計書執筆LLM**: 元の要件と分析結果、そしてレビュー結果を基に設計書を執筆・修正するライター。
* **設計書レビューLLM**: 執筆された設計書を厳しく評価し、改善点を指摘するレビュアー。

## ループによる反復的改善

`ループ`ノードを使うと、「**指定した条件が満たされるまで**」パイプライン内の処理を繰り返すことができます。今回はこれを利用して「**執筆→レビュー→（改善点があれば）→修正**」という、人間が行うような品質向上のためのフィードバックループを自動化します。レビュアーLLMからの指摘がなくなるまで、設計書は何度も推敲されます。

:::warning
`ループ`ノードの設定画面では`最大ループ回数`を設定可能です。
終了条件を満たすか、最大ループ回数に達した時点でループを抜け出します。
以下の点を理解した上で、最適なループ回数を設定してください。
- `LLM`ノードが回答を生成するたびにトークンコストが発生します。
- 各モデルごとに、APIのリクエスト上限数が決まっています。詳細は公式サイトをご確認ください。
:::

### Step 3: 設計書を執筆・修正する（LLM（執筆） @ループ内）

1.  ループノード内にある`＋ブロックを追加`ボタンをクリックし、ループ内の1つ目のLLMとして「LLM（執筆）」を追加します。このLLMは、初回は分析結果から、2回目以降はレビュー結果をもとに設計書を執筆します。
2.  `SYSTEM` に、設計書を作成・修正するための詳細なシステムプロンプトを貼り付けます。

```markdown

# 役割
あなたは、複雑な要件を明確で構造化された技術設計書に落とし込むことを得意とするシステムアーキテクトです。

# タスク
提供された「要件定義書」「分析・要約された技術情報」そして「前回のレビュー指摘事項」を基に、以下の形式でマークダウン形式のAPI設計書を作成または修正してください。
「前回のレビュー指摘事項」が空の場合は、新規に設計書を作成します。指摘事項がある場合は、それをすべて反映した上で、より完成度の高い設計書にしてください。

# 出力形式
## 1. 機能概要
（要件を基に記述）
## 2. APIエンドポイント
- Method: (GET/POST/PUT/DELETE)
- Path: /api/v1/...
## 3. リクエスト仕様
（ヘッダー、パスパラメータ、クエリパラメータ、リクエストボディなど）
## 4. レスポンス仕様
（成功時(200 OK)、エラー時(400, 500)のJSONレスポンス例など）
## 5. 採用技術とアーキテクチャ
（分析結果とレビュー指摘を基に、なぜその技術を選択したかの理由を明確に記述）

```

3.  `USER` の欄に、以下の変数を設定します。
    ```
    #要件定義書
    {テキスト抽出/text}
    #分析・要約された設計書案
    {LLM（分析・要約）/text}
    #レビュー指摘事項
    {ループ/review_comments} 
    ```
![](https://chataniakinori-no1s.github.io/prompt_engineering/PromptEngineering_lv02_ja/assets/chapter02/img/work11-6.png)

:::point
ループ変数に`review_comments`を設定したのには2つ理由があります。
ひとつはループを抜けるための条件として使用することです。
ふたつ目は、`LLM（執筆）`ノードのUSER欄で、レビューコメントを渡すために使用するからです。`LLM（執筆）`ノードは`LLM（修正）`ノードより前の処理にあたるため、後続の`LLM（修正）`ノードの出力変数textを設定することができません。
:::

### Step 4: 設計書をレビューする（LLM（修正） @ループ内）

1.  ループ内の2つ目のLLMを「LLM（修正）」とし、`執筆LLM` の後続に配置します。
2.  `システムプロンプト` に、第5章で学んだ**メタ認知プロンプト**を応用し、自己評価させる指示を与えます。

```markdown
# 役割
あなたは、設計書の些細な不備も見逃さない、品質に非常に厳しいプリンシパルエンジニアです。

# タスク
以下の「要件定義書」と、それに基づいて作成された「設計書ドラフト」をレビューしてください。
以下のチェックリストに基づき、具体的で建設的な改善点を最大3つ、箇条書きで指摘してください。
**もし改善点が一切なければ、必ず「指摘事項なし」とだけ出力してください。**この応答がループを終了させるトリガーになります。

# レビュー観点
- 要件網羅性: 元の要件がすべて満たされているか？
- 技術的妥当性: 提案されている技術選定やアーキテクチャは合理的か？
- 明確性: 曖昧な表現がなく、誰が読んでも一意に解釈できるか？

```

3.  `USER` の欄に、以下の変数を設定します。
    ```
    #要件定義書
    {テキスト抽出/text}
    #設計書ドラフト
    {LLM（執筆）/text}
    ```
![](https://chataniakinori-no1s.github.io/prompt_engineering/PromptEngineering_lv02_ja/assets/chapter02/img/work11-7.png)

4.  `ループ` ノードをクリックし、以下の設定を追加します。
    * **`ループ終了条件`**:
        * `{LLM（修正）/text}` `含む` `指摘事項なし`
        * **解説**: ループ内の`LLM（修正）`ノードの出力に「指摘事項なし」という文字列が含まれた場合に、ループを終了させます。

![](https://chataniakinori-no1s.github.io/prompt_engineering/PromptEngineering_lv02_ja/assets/chapter02/img/work11-8.png)

### Step 5: ループの状態を更新する（変数代入ノード @ループ内）

現在の処理だと、`LLM（執筆）`ノードの`USER`欄に設定したレビューコメントを格納するための変数`{ループ/review_comments}`には、値が入りません。

このループで生成された「レビューコメント」を、次のループが開始する前に**ループ変数の値を上書き**して記憶させましょう。

1.  ループ内の `LLM（修正）`ノード の次に、`変数代入` ノードを追加します。
2.  `変数`セクションで`+`を押し、以下のように設定します。
    * **1つ目**:
        * `変数`: `ループ.draft_document` を選択
        * `操作`: `上書き`
        * `値`: `LLM（執筆）` の出力 `{LLM（執筆）/text}` を設定
    * **2つ目**:
        * `変数`: `ループ.review_comments` を選択
        * `操作`: `上書き`
        * `値`: `LLM（修正）` の出力 `{LLM（修正）/text}` を設定

![](https://chataniakinori-no1s.github.io/prompt_engineering/PromptEngineering_lv02_ja/assets/chapter02/img/work11-9.png)

### Step 6: Word (DOCX) ドキュメントに変換して出力する

1.  `ループ` ノードの次に、`[ツール]` から `DOC` ノードを追加します。
![](https://chataniakinori-no1s.github.io/prompt_engineering/PromptEngineering_lv02_ja/assets/chapter02/img/work11-10.png)

2.  **DOCノードの設定**:
    * `Markdownコンテンツ` : `ループ` ノードの**出力**`{ループ/draft_document}` を設定します。
    * `draft_document`: 任意のファイル名を入力します。
![](https://chataniakinori-no1s.github.io/prompt_engineering/PromptEngineering_lv02_ja/assets/chapter02/img/work11-11.png)

3.  `DOC` ノードを `終了` ノードに接続します。
4.  `終了` ノードをクリックし、`出力変数` にてDOCツールの出力（例: `{DOC/file}`）を選択します。

### Step 6: テストと実行

すべてのパイプラインが完成しました。プレビュー画面で最終動作を確認しましょう。

前回のワークに引き続き、開始時にアップロードするファイルは以下をご利用ください。
フォルダパス:`PromptEngineering_lv02_ja\assets\chapter02\リアルタイム翻訳スマホアプリ要件定義書.docx`

1.  `[実行]` をクリックし、要件定義書ファイルをアップロードして`[実行開始]` します。
2.  左側の開発画面で、ループノードが何度か（レビューの指摘がなくなるまで）実行される様子を確認できます。
3.  処理が完了すると、出力欄にWordファイルが生成され、ダウンロードできるようになります。ファイルを開き、推敲が重ねられた最終設計書が書き込まれていれば、大成功です。
![](https://chataniakinori-no1s.github.io/prompt_engineering/PromptEngineering_lv02_ja/assets/chapter02/img/work11-12.png)

お疲れ様でした！ 
これで、要件定義書のアップロードから、LLMチェーンと外部ツールによる連携、品質改善ループを経て、設計書をWordドキュメントとして自動生成する、実用的なワークフローが完成しました。